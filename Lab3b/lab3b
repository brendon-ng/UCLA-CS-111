#!/usr/bin/python

import sys
import csv
from collections import defaultdict

superBlock = None
groups = []
bfree = []
ifree = []
inodes = []
dirents = []
indirects = []
exit_stat = 0
refs_to_blocks = defaultdict(list)
levels = ["", "INDIRECT ", "DOUBLE INDIRECT ", "TRIPLE INDIRECT "]

class SuperBlock:
   def __init__(self, row):
      self.n_blocks = int(row[1])
      self.n_inodes = int(row[2])
      self.s_block = int(row[3])
      self.s_inode = int(row[4])
      self.blocks= int(row[5])
      self.inodes= int(row[6])
      self.firstInode =int(row[5])
      self.s_table = self.n_inodes*self.s_inode / self.s_block + 1
      self.firstBlock = self.s_table + 4

class Group:
   def __init__(self, row):
      self.num = int(row[1])
      self.n_blocks = int(row[2])
      self.n_inodes = int(row[3])
      self.n_bfree = int(row[4])
      self.n_ifree = int(row[5])

class Inode:
   def __init__(self, row):
      self.num = int(row[1])
      self.fileType = row[2]
      self.mode = int(row[3])
      self.owner = int(row[4])
      self.group = int(row[5])
      self.links = int(row[6])
      self.ctime = row[7]
      self.mtime = row[8]
      self.atime = row[9]
      self.s_file = int(row[10])
      self.n_blocks = int(row[11])
      self.directBlocks = map(int, row[12:24])
      self.singleIndirect = int(row[24])
      self.doubleIndirect = int(row[25])
      self.tripleIndirect = int(row[26])

class Dirent:
   def __init__(self,row):
      self.parent = int(row[1])
      self.offset = int(row[2])
      self.inode = int(row[3])
      self.l_entry = int(row[4])
      self.l_name = int(row[5])
      self.name = row[6]

class Indirect:
   def __init__(self, row):
      self.inode = int(row[1])
      self.level = int(row[2])
      self.offset = int(row[3])
      self.indirectBlock = int(row[4])
      self.referenceBlock = int(row[5])

class Reference:
   def __init__(self, block, inode, offset, level):
      self.block = block
      self.inode = inode
      self.offset = offset
      self.level = level

def validBlock(block, inode, offset, level):
   global exit_stat
   if level == 0:
      type = ""
   elif level == 1:
      type = "INDIRECT "
   elif level == 2:
      type = "DOUBLE INDIRECT "
   elif level == 3:
      type = "TRIPLE INDIRECT "
   
   if block == 0:
      return

   # check for invalidity
   if block < 0 or block > superBlock.n_blocks:
      print("INVALID "+ str(type) + "BLOCK " + str(block) + " IN INODE " + str(inode) + " AT OFFSET " + str(offset))
      exit_stat = 2
   elif block < superBlock.firstBlock:
      print("RESERVED " + str(type) + "BLOCK " + str(block) + " IN INODE " + str(inode) + " AT OFFSET " + str(offset))
      exit_stat = 2
   else: # valid
      refs_to_blocks[block].append(Reference(block, inode, offset, level))

if __name__ == '__main__':
   if len(sys.argv) != 2:
      sys.stderr.write("Incorrect number of arguments! Usage: ./lab3b file.csv\n")
      exit(1)
      
   csv = csv.reader(open(sys.argv[1],'r'))
   for row in csv:
      if len(row) <= 0:
         sys.stderr.write("Error: Empty line in file!\n")
         exit(1)

      type = row[0]
      if type == "SUPERBLOCK":
         superBlock = SuperBlock(row);
      elif type == "GROUP":
         groups.append(Group(row))
      elif type == "BFREE":
         bfree.append(int(row[1]))
      elif type == "IFREE":
         ifree.append(int(row[1]))
      elif type == "INODE":
         inodes.append(Inode(row))
      elif type == "DIRENT":
         dirents.append(Dirent(row))
      elif type == "INDIRECT":
         indirects.append(Indirect(row))
      else:
         sys.stderr.write("Error: Invalid entry type in csv file: %s\n" % type)
         exit(1)



   for inode in inodes:
      if inode.fileType == 's' and inode.s_file <= 60:
         continue

      #direct blocks
      offset = 0
      for b in inode.directBlocks:
         validBlock(b, inode.num, offset, 0)
         offset+=1

      #check indirect blocks
      validBlock(inode.singleIndirect, inode.num, 12, 1)
      validBlock(inode.doubleIndirect, inode.num, 268, 2)
      validBlock(inode.tripleIndirect, inode.num, 65804, 3)

   for indirect in indirects:
      validBlock(indirect.referenceBlock, indirect.inode, indirect.offset, indirect.level)

   for block in range(superBlock.firstBlock, superBlock.n_blocks):
      if block not in refs_to_blocks and block not in bfree:
         print("UNREFERENCED BLOCK " + str(block))
         exit_stat = 2
      elif block in refs_to_blocks and block in bfree:
         print("ALLOCATED BLOCK " + str(block) + " ON FREELIST")
         exit_stat = 2
      elif block in refs_to_blocks and len(refs_to_blocks[int(block)]) > 1:
         for block_ref in refs_to_blocks[int(block)]:
            print("DUPLICATE " + levels[int(block_ref.level)] + "BLOCK " + str(block_ref.block) + " IN INODE " + str(block_ref.inode) + " AT OFFSET " + str(block_ref.offset))
            exit_stat = 2

   # Inodes
   unallocated = ifree
   allocated = []
   for inode in inodes:
      if inode.fileType != '0':
         if inode.num in ifree:
            print("ALLOCATED INODE " + str(inode.num) + " ON FREELIST")
            unallocated.remove(inode.num)
            exit_stat = 2
         allocated.append(inode)
      else:
         if inode.num not in ifree:
            print("UNALLOCATED INODE " + str(inode.num) + " NOT ON FREELIST")
            unallocated.append(inode.num)
      for i in range(superBlock.firstInode, superBlock.n_inodes):
         if i not in ifree:
            for inode in inodes:
               if inode.num == i:
                  continue
            print("UNALLOCATED INODE " + str(i) + " NOT ON FREELIST")
            unallocated.append(i)
            exit_stat=2
   exit(exit_stat)
